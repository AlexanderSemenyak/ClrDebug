<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/********************************************************** ***********
 * This code was generated by a tool.                                 *
 * Please do not modify this file directly - modify Tokens.tt instead *
 **********************************************************************/
using System;
using System.Diagnostics;

namespace ClrDebug
{
<#
var types = new[]
{
    Tuple.Create("CORDB_ADDRESS", "long"),
    Tuple.Create("CORDB_REGISTER", "long"),
    Tuple.Create("CLRDATA_ADDRESS", "long") //https://github.com/dotnet/runtime/blob/main/src/coreclr/debug/daccess/dacimpl.h
};

for(int i = 0; i < types.Length; i++)
{
    var type = types[i].Item1;
    var baseType = types[i].Item2;
#>
    [Serializable]
    [DebuggerDisplay("{ToString(),nq}")]
    public struct <#= type #> : IComparable, IEquatable<<#= type #>>
    {
        public u<#= baseType #> Value { get; }

        public <#= type == "CLRDATA_ADDRESS" ? "unsafe " : "" #><#= type #>(u<#= baseType #> value)
        {
<#
if (type == "CLRDATA_ADDRESS")
{
#>
            Value = new UIntPtr((void*)value).ToUInt64();
<#
}
else
{
#>
            Value = value;
<#
}
#>
        }

        public <#= type #>(<#= baseType #> value) : this((u<#= baseType #>) value)
        {
        }

        public static implicit operator <#= baseType #>(<#= type #> value) => (<#= baseType #>) value.Value;

        public static implicit operator u<#= baseType #>(<#= type #> value) => value.Value;

        public static implicit operator <#= type #>(<#= baseType #> value) => new <#= type #>(value);

        public static implicit operator <#= type #>(u<#= baseType #> value) => new <#= type #>(value);

<#
//Numeric literals are implicitly integers; as such, without an implicit conversion from int -> wrapper type,
//we can't assign a numeric literal to a parameter expecting a wrapper type
if (baseType != "int")
{
#>
        public static implicit operator <#= type #>(int value) => new <#= type #>(value);
<#
}
if (type == "CORDB_ADDRESS")
{
#>

        public static implicit operator <#= type #>(IntPtr value) => new <#= type #>(value.ToInt64());

        public static implicit operator IntPtr(CORDB_ADDRESS value) => new IntPtr(value);

        public static implicit operator CLRDATA_ADDRESS(CORDB_ADDRESS value) => new CLRDATA_ADDRESS(value);
<#
}
if (type == "CLRDATA_ADDRESS")
{
#>

        public static implicit operator <#= type #>(IntPtr value) => new <#= type #>(value.ToInt64());

        public static implicit operator IntPtr(CLRDATA_ADDRESS value) => new IntPtr(value);

        public static implicit operator CORDB_ADDRESS(CLRDATA_ADDRESS value) => new CORDB_ADDRESS(value);
<#
}
#>

        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo<<#= type #>>(Value, value);

        public bool Equals(<#= type #> other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }
<#
if (i < types.Length - 1)
    WriteLine("");
}
#>
}