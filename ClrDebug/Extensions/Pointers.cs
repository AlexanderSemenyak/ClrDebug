/************************************************************************
 * This code was generated by a tool.                                   *
 * Please do not modify this file directly - modify Pointers.tt instead *
 ************************************************************&***********/
using System;
using System.Diagnostics;

namespace ClrDebug
{
    [Serializable]
    [DebuggerDisplay("{ToString(),nq}")]
    public unsafe struct CORDB_ADDRESS : IComparable, IEquatable<CORDB_ADDRESS>
    {
        public ulong Value { get; }

        public CORDB_ADDRESS(ulong value)
        {
            Value = value;
        }

        public CORDB_ADDRESS(long value) : this((ulong) value)
        {
        }

        public static implicit operator long(CORDB_ADDRESS value) => (long) value.Value;

        public static implicit operator ulong(CORDB_ADDRESS value) => value.Value;

        public static implicit operator CORDB_ADDRESS(long value) => new CORDB_ADDRESS(value);

        public static implicit operator CORDB_ADDRESS(ulong value) => new CORDB_ADDRESS(value);

        //Don't use ToInt64 as IntPtr will first cast the pointer to int, causing the value to become 0xffffffffxxxxxxxx
        public static implicit operator CORDB_ADDRESS(IntPtr value) => new CORDB_ADDRESS((ulong)(void*)value);

        //IntPtr does a checked conversion when the int/long ctor is used, meaning that when the high bit of a 32-bit address is set (which)
        //would be perfectly valid since the address is a ulong) IntPtr will throw an OverflowException. By using the void* ctor,
        //we bypass this check
        public static implicit operator IntPtr(CORDB_ADDRESS value) => new IntPtr((void*)value.Value);

        public static implicit operator CORDB_ADDRESS(int value) => new CORDB_ADDRESS(value);

        public static implicit operator CORDB_ADDRESS(uint value) => new CORDB_ADDRESS(value);

        public static implicit operator CLRDATA_ADDRESS(CORDB_ADDRESS value) => new CLRDATA_ADDRESS(value);

        public static CORDB_ADDRESS operator+ (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value + right.Value;
        public static CORDB_ADDRESS operator+ (CORDB_ADDRESS left, int right) => (long) left.Value + (long) right;
        public static CORDB_ADDRESS operator- (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value - right.Value;
        public static CORDB_ADDRESS operator- (CORDB_ADDRESS left, int right) => (long) left.Value - (long) right;
        public static CORDB_ADDRESS operator& (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value & right.Value;
        public static CORDB_ADDRESS operator& (CORDB_ADDRESS left, int right) => (long) left.Value & (long) right;
        public static CORDB_ADDRESS operator| (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value | right.Value;
        public static CORDB_ADDRESS operator| (CORDB_ADDRESS left, int right) => (long) left.Value | (long) right;
        public static CORDB_ADDRESS operator* (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value * right.Value;
        public static CORDB_ADDRESS operator* (CORDB_ADDRESS left, int right) => (long) left.Value * (long) right;
        public static CORDB_ADDRESS operator/ (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value / right.Value;
        public static CORDB_ADDRESS operator/ (CORDB_ADDRESS left, int right) => (long) left.Value / (long) right;
        public static CORDB_ADDRESS operator% (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value % right.Value;
        public static CORDB_ADDRESS operator% (CORDB_ADDRESS left, int right) => (long) left.Value % (long) right;
        public static bool operator> (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value > right.Value;
        public static bool operator> (CORDB_ADDRESS left, int right) => left.Value > (ulong) right;
        public static bool operator< (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value < right.Value;
        public static bool operator< (CORDB_ADDRESS left, int right) => left.Value < (ulong) right;
        public static bool operator== (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value == right.Value;
        public static bool operator== (CORDB_ADDRESS left, int right) => left.Value == (ulong) right;
        public static bool operator!= (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value != right.Value;
        public static bool operator!= (CORDB_ADDRESS left, int right) => left.Value != (ulong) right;
        public static bool operator>= (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value >= right.Value;
        public static bool operator>= (CORDB_ADDRESS left, int right) => left.Value >= (ulong) right;
        public static bool operator<= (CORDB_ADDRESS left, CORDB_ADDRESS right) => left.Value <= right.Value;
        public static bool operator<= (CORDB_ADDRESS left, int right) => left.Value <= (ulong) right;

        public static CORDB_ADDRESS operator~(CORDB_ADDRESS value) => ~value.Value;

        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo(Value, value is CORDB_ADDRESS v ? v.Value : value);

        public bool Equals(CORDB_ADDRESS other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }

    [Serializable]
    [DebuggerDisplay("{ToString(),nq}")]
    public unsafe struct CORDB_REGISTER : IComparable, IEquatable<CORDB_REGISTER>
    {
        public ulong Value { get; }

        public CORDB_REGISTER(ulong value)
        {
            Value = value;
        }

        public CORDB_REGISTER(long value) : this((ulong) value)
        {
        }

        public static implicit operator long(CORDB_REGISTER value) => (long) value.Value;

        public static implicit operator ulong(CORDB_REGISTER value) => value.Value;

        public static implicit operator CORDB_REGISTER(long value) => new CORDB_REGISTER(value);

        public static implicit operator CORDB_REGISTER(ulong value) => new CORDB_REGISTER(value);

        //Don't use ToInt64 as IntPtr will first cast the pointer to int, causing the value to become 0xffffffffxxxxxxxx
        public static implicit operator CORDB_REGISTER(IntPtr value) => new CORDB_REGISTER((ulong)(void*)value);

        //IntPtr does a checked conversion when the int/long ctor is used, meaning that when the high bit of a 32-bit address is set (which)
        //would be perfectly valid since the address is a ulong) IntPtr will throw an OverflowException. By using the void* ctor,
        //we bypass this check
        public static implicit operator IntPtr(CORDB_REGISTER value) => new IntPtr((void*)value.Value);

        public static implicit operator CORDB_REGISTER(int value) => new CORDB_REGISTER(value);

        public static implicit operator CORDB_REGISTER(uint value) => new CORDB_REGISTER(value);

        public static CORDB_REGISTER operator+ (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value + right.Value;
        public static CORDB_REGISTER operator+ (CORDB_REGISTER left, int right) => (long) left.Value + (long) right;
        public static CORDB_REGISTER operator- (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value - right.Value;
        public static CORDB_REGISTER operator- (CORDB_REGISTER left, int right) => (long) left.Value - (long) right;
        public static CORDB_REGISTER operator& (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value & right.Value;
        public static CORDB_REGISTER operator& (CORDB_REGISTER left, int right) => (long) left.Value & (long) right;
        public static CORDB_REGISTER operator| (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value | right.Value;
        public static CORDB_REGISTER operator| (CORDB_REGISTER left, int right) => (long) left.Value | (long) right;
        public static CORDB_REGISTER operator* (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value * right.Value;
        public static CORDB_REGISTER operator* (CORDB_REGISTER left, int right) => (long) left.Value * (long) right;
        public static CORDB_REGISTER operator/ (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value / right.Value;
        public static CORDB_REGISTER operator/ (CORDB_REGISTER left, int right) => (long) left.Value / (long) right;
        public static CORDB_REGISTER operator% (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value % right.Value;
        public static CORDB_REGISTER operator% (CORDB_REGISTER left, int right) => (long) left.Value % (long) right;
        public static bool operator> (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value > right.Value;
        public static bool operator> (CORDB_REGISTER left, int right) => left.Value > (ulong) right;
        public static bool operator< (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value < right.Value;
        public static bool operator< (CORDB_REGISTER left, int right) => left.Value < (ulong) right;
        public static bool operator== (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value == right.Value;
        public static bool operator== (CORDB_REGISTER left, int right) => left.Value == (ulong) right;
        public static bool operator!= (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value != right.Value;
        public static bool operator!= (CORDB_REGISTER left, int right) => left.Value != (ulong) right;
        public static bool operator>= (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value >= right.Value;
        public static bool operator>= (CORDB_REGISTER left, int right) => left.Value >= (ulong) right;
        public static bool operator<= (CORDB_REGISTER left, CORDB_REGISTER right) => left.Value <= right.Value;
        public static bool operator<= (CORDB_REGISTER left, int right) => left.Value <= (ulong) right;

        public static CORDB_REGISTER operator~(CORDB_REGISTER value) => ~value.Value;

        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo(Value, value is CORDB_REGISTER v ? v.Value : value);

        public bool Equals(CORDB_REGISTER other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }

    [Serializable]
    [DebuggerDisplay("{ToString(),nq}")]
    public unsafe struct CLRDATA_ADDRESS : IComparable, IEquatable<CLRDATA_ADDRESS>
    {
        public ulong Value { get; }

        public CLRDATA_ADDRESS(ulong value)
        {
            Value = (ulong) (void*) value;
        }

        public CLRDATA_ADDRESS(long value) : this((ulong) value)
        {
        }

        public static implicit operator long(CLRDATA_ADDRESS value) => (long) value.Value;

        public static implicit operator ulong(CLRDATA_ADDRESS value) => value.Value;

        public static implicit operator CLRDATA_ADDRESS(long value) => new CLRDATA_ADDRESS(value);

        public static implicit operator CLRDATA_ADDRESS(ulong value) => new CLRDATA_ADDRESS(value);

        //Don't use ToInt64 as IntPtr will first cast the pointer to int, causing the value to become 0xffffffffxxxxxxxx
        public static implicit operator CLRDATA_ADDRESS(IntPtr value) => new CLRDATA_ADDRESS((ulong)(void*)value);

        //IntPtr does a checked conversion when the int/long ctor is used, meaning that when the high bit of a 32-bit address is set (which)
        //would be perfectly valid since the address is a ulong) IntPtr will throw an OverflowException. By using the void* ctor,
        //we bypass this check
        public static implicit operator IntPtr(CLRDATA_ADDRESS value) => new IntPtr((void*)value.Value);

        public static implicit operator CLRDATA_ADDRESS(int value) => new CLRDATA_ADDRESS(value);

        public static implicit operator CLRDATA_ADDRESS(uint value) => new CLRDATA_ADDRESS(value);

        public static implicit operator CORDB_ADDRESS(CLRDATA_ADDRESS value) => new CORDB_ADDRESS(value);

        public static CLRDATA_ADDRESS operator+ (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value + right.Value;
        public static CLRDATA_ADDRESS operator+ (CLRDATA_ADDRESS left, int right) => (long) left.Value + (long) right;
        public static CLRDATA_ADDRESS operator- (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value - right.Value;
        public static CLRDATA_ADDRESS operator- (CLRDATA_ADDRESS left, int right) => (long) left.Value - (long) right;
        public static CLRDATA_ADDRESS operator& (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value & right.Value;
        public static CLRDATA_ADDRESS operator& (CLRDATA_ADDRESS left, int right) => (long) left.Value & (long) right;
        public static CLRDATA_ADDRESS operator| (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value | right.Value;
        public static CLRDATA_ADDRESS operator| (CLRDATA_ADDRESS left, int right) => (long) left.Value | (long) right;
        public static CLRDATA_ADDRESS operator* (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value * right.Value;
        public static CLRDATA_ADDRESS operator* (CLRDATA_ADDRESS left, int right) => (long) left.Value * (long) right;
        public static CLRDATA_ADDRESS operator/ (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value / right.Value;
        public static CLRDATA_ADDRESS operator/ (CLRDATA_ADDRESS left, int right) => (long) left.Value / (long) right;
        public static CLRDATA_ADDRESS operator% (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value % right.Value;
        public static CLRDATA_ADDRESS operator% (CLRDATA_ADDRESS left, int right) => (long) left.Value % (long) right;
        public static bool operator> (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value > right.Value;
        public static bool operator> (CLRDATA_ADDRESS left, int right) => left.Value > (ulong) right;
        public static bool operator< (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value < right.Value;
        public static bool operator< (CLRDATA_ADDRESS left, int right) => left.Value < (ulong) right;
        public static bool operator== (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value == right.Value;
        public static bool operator== (CLRDATA_ADDRESS left, int right) => left.Value == (ulong) right;
        public static bool operator!= (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value != right.Value;
        public static bool operator!= (CLRDATA_ADDRESS left, int right) => left.Value != (ulong) right;
        public static bool operator>= (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value >= right.Value;
        public static bool operator>= (CLRDATA_ADDRESS left, int right) => left.Value >= (ulong) right;
        public static bool operator<= (CLRDATA_ADDRESS left, CLRDATA_ADDRESS right) => left.Value <= right.Value;
        public static bool operator<= (CLRDATA_ADDRESS left, int right) => left.Value <= (ulong) right;

        public static CLRDATA_ADDRESS operator~(CLRDATA_ADDRESS value) => ~value.Value;

        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo(Value, value is CLRDATA_ADDRESS v ? v.Value : value);

        public bool Equals(CLRDATA_ADDRESS other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }
}