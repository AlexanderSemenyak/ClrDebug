<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/********************************************************** ***********
 * This code was generated by a tool.                                 *
 * Please do not modify this file directly - modify Tokens.tt instead *
 **********************************************************************/
 using System;
 using System.Diagnostics;

namespace ClrDebug
{
<#
var types = new[]
{
    "mdToken",
    "mdModule",
    "mdTypeRef",
    "mdTypeDef",
    "mdFieldDef",
    "mdMethodDef",
    "mdParamDef",
    "mdInterfaceImpl",
    "mdMemberRef",
    "mdCustomAttribute",
    "mdPermission",
    "mdSignature",
    "mdEvent",
    "mdProperty",
    "mdModuleRef",
    "mdAssembly",
    "mdAssemblyRef",
    "mdFile",
    "mdExportedType",
    "mdManifestResource",
    "mdTypeSpec",
    "mdGenericParam",
    "mdMethodSpec",
    "mdGenericParamConstraint",
    "mdString",
    "mdCPToken"
};

for(int i = 0; i < types.Length; i++)
{
    var type = types[i];

	if (type == "mdToken")
	{
#>
	[DebuggerDisplay("{ToString(),nq} [{Type}]")]
<#
	}
	else
	{
#>
    [DebuggerDisplay("{ToString(),nq} [<#= type #>]")]
<#
	}
#>
    public struct <#= type #> : IComparable, IEquatable<<#= type #>>
    {
        <#
            if(type == "mdToken")
            {
        #>
public static readonly <#= type #> Nil = new <#= type #>();
        <#
				WriteLine("");
				Write("        ");
            }
            else if(type != "mdCPToken")
            {
        #>
public static readonly <#= type #> Nil = new <#= type #>((uint) CorTokenType.<#= type.Insert(2, "t") #>);
        <#
                WriteLine("");
				Write("        ");
            }
        #>
public uint Rid => Value & 0x00FFFFFF;

        public CorTokenType Type => (CorTokenType) (Value & 0xFF000000);

        public uint Value { get; }

        public bool IsNil => Rid == 0;

        public <#= type #>(uint value)
        {
            Value = value;
        }

        public <#= type #>(int value) : this((uint) value)
        {
        }

        public static implicit operator int(<#= type #> value) => (int) value.Value;

        public static implicit operator uint(<#= type #> value) => value.Value;

        public static implicit operator <#= type #>(int value) => new <#= type #>(value);

        public static implicit operator <#= type #>(uint value) => new <#= type #>(value);

<#
    if(type == "mdToken")
    {
        for(var j = 1; j < types.Length; j++)
        {
            if (types[j] == "mdCPToken")
                continue;
#>
        public static explicit operator <#= types[j] #>(<#= type #> value)
        {
            if (value.Type != CorTokenType.<#= (types[j]).Insert(2, "t") #>)
                throw new InvalidOperationException($"Cannot cast a value of type '{value.Type}' to a token of type '<#= types[j] #>'.");

            return new <#= types[j] #>(value.Value);
        }
<#
            if (j < types.Length - 1)
                WriteLine("");
        }
    }
	else
	{
#>
		public static implicit operator mdToken(<#= type #> value) => new mdToken(value.Value);

<#
	}
#>
        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo<<#= type #>>(Value, value);

        public bool Equals(<#= type #> other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }
<#
if (i < types.Length - 1)
    WriteLine("");
}
#>
}