<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/************************************************************************
 * This code was generated by a tool.                                   *
 * Please do not modify this file directly - modify Profiler.tt instead *
 ***********************************************************************/
using System;
using System.Diagnostics;

namespace ClrDebug
{
<#
var types = new[]
{
    Tuple.Create("ProcessID", "IntPtr"),
    Tuple.Create("AssemblyID", "IntPtr"),
    Tuple.Create("AppDomainID", "IntPtr"),
    Tuple.Create("ModuleID", "IntPtr"),
    Tuple.Create("ClassID", "IntPtr"),
    Tuple.Create("ThreadID", "IntPtr"),
    Tuple.Create("ContextID", "IntPtr"),
    Tuple.Create("FunctionID", "IntPtr"),
    Tuple.Create("ObjectID", "IntPtr"),
    Tuple.Create("GCHandleID", "IntPtr"),
    Tuple.Create("COR_PRF_ELT_INFO", "IntPtr"),
    Tuple.Create("COR_PRF_FRAME_INFO", "IntPtr"),
    Tuple.Create("ReJITID", "IntPtr"),
    Tuple.Create("EVENTPIPE_PROVIDER", "IntPtr"),
    Tuple.Create("EVENTPIPE_EVENT", "IntPtr"),
    Tuple.Create("EVENTPIPE_SESSION", "long")
};

for(int i = 0; i < types.Length; i++)
{
    var type = types[i].Item1;
    var baseType = types[i].Item2;
#>
    [Serializable]
    [DebuggerDisplay("{ToString(),nq}")]
    public unsafe struct <#= type #> : IComparable, IEquatable<<#= type #>>
    {
        public <#= baseType #> Value { get; }

        public <#= type #>(<#= baseType #> value)
        {
            Value = value;
        }

        public static implicit operator <#= baseType #>(<#= type #> value) => value.Value;

        public static implicit operator <#= type #>(<#= baseType #> value) => new <#= type #>(value);

<#
if (baseType == "IntPtr")
{
#>
        public static implicit operator <#= type #>(long value) => new <#= type #>(new IntPtr((void*)value));

        public static implicit operator <#= type #>(ulong value) => new <#= type #>(new IntPtr((void*)value));
<#
}
//Numeric literals are implicitly integers; as such, without an implicit conversion from int -> wrapper type,
//we can't assign a numeric literal to a parameter expecting a wrapper type
if (baseType != "int")
{
#>

        public static implicit operator <#= type #>(int value) => new <#= type #>((<#= baseType #>) value);
<#
}
//Numeric literals are implicitly integers; as such, without an implicit conversion from int -> wrapper type,
//we can't assign a numeric literal to a parameter expecting a wrapper type
if (baseType == "IntPtr")
{
#>

        public static implicit operator long(<#= type #> value) => (long) (void*) value.Value;

        public static implicit operator ulong(<#= type #> value) => (ulong) (void*) value.Value;
<#
}
#>

        public int CompareTo(object value) => UnsignedValueHelpers.CompareTo<<#= type #>>((ulong) Value, value);

        public bool Equals(<#= type #> other) => other.Value.Equals(Value);

        public override bool Equals(object obj) => UnsignedValueHelpers.Equals(this, obj);

        public static bool operator ==(<#= type #> left, <#= type #> right) => left.Value == right.Value;

        public static bool operator !=(<#= type #> left, <#= type #> right) => left.Value != right.Value;

        public override int GetHashCode() => Value.GetHashCode();

        public override string ToString() => "0x" + Value.ToString("X");
    }
<#
if (i < types.Length - 1)
    WriteLine("");
}
#>
}